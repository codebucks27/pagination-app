{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar statusIdle = 'idle';\nvar statusLoading = 'loading';\nvar statusError = 'error';\nvar statusSuccess = 'success';\nvar _uid = 0;\n\nvar uid = function uid() {\n  return _uid++;\n};\n\nvar cancelledError = {};\nvar isServer = typeof window === 'undefined';\n\nvar noop = function noop() {};\n\nvar identity = function identity(d) {\n  return d;\n};\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\n\nfunction useUid() {\n  var ref = React.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = uid();\n  }\n\n  return ref.current;\n}\n\nfunction setConsole(c) {\n  Console = c;\n}\n\nfunction useGetLatest(obj) {\n  var ref = React.useRef();\n  ref.current = obj;\n  return React.useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater;\n}\n\nfunction stableStringifyReplacer(_, value) {\n  return isObject(value) ? Object.assign.apply(Object, [{}].concat(Object.keys(value).sort().map(function (key) {\n    var _ref;\n\n    return _ref = {}, _ref[key] = value[key], _ref;\n  }))) : value;\n}\n\nfunction stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer);\n}\n\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n}\n\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction isDocumentVisible() {\n  return typeof document === 'undefined' || document.visibilityState === undefined || document.visibilityState === 'visible' || document.visibilityState === 'prerender';\n}\n\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\n\nfunction getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (args[0].hasOwnProperty('queryKey') && args[0].hasOwnProperty('queryFn')) {\n      var _args$ = args[0],\n          _queryKey = _args$.queryKey,\n          _args$$variables = _args$.variables,\n          variables = _args$$variables === void 0 ? [] : _args$$variables,\n          _queryFn = _args$.queryFn,\n          _args$$config = _args$.config,\n          _config = _args$$config === void 0 ? {} : _args$$config;\n\n      return [_queryKey, variables, _queryFn, _config];\n    } else {\n      throw new Error('queryKey and queryFn keys are required.');\n    }\n  }\n\n  if (typeof args[2] === 'function') {\n    var _queryKey2 = args[0],\n        _args$2 = args[1],\n        _variables = _args$2 === void 0 ? [] : _args$2,\n        _queryFn2 = args[2],\n        _args$3 = args[3],\n        _config2 = _args$3 === void 0 ? {} : _args$3;\n\n    return [_queryKey2, _variables, _queryFn2, _config2];\n  }\n\n  var queryKey = args[0],\n      queryFn = args[1],\n      _args$4 = args[2],\n      config = _args$4 === void 0 ? {} : _args$4;\n  return [queryKey, [], queryFn, config];\n}\n\nfunction useMountedCallback(callback) {\n  var mounted = React.useRef(false);\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mounted.current = true;\n    return function () {\n      return mounted.current = false;\n    };\n  }, []);\n  return React.useCallback(function () {\n    return mounted.current ? callback.apply(void 0, arguments) : void 0;\n  }, [callback]);\n}\n\nfunction handleSuspense(queryInfo) {\n  if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {\n    if (queryInfo.status === statusError) {\n      setTimeout(function () {\n        queryInfo.query.state.status = 'loading';\n      });\n      throw queryInfo.error;\n    }\n  }\n\n  if (queryInfo.config.suspense) {\n    if (queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true;\n      throw queryInfo.refetch();\n    }\n  }\n} // This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\n\n\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length; // eslint-disable-next-line eqeqeq\n\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nvar configContext = React.createContext();\nvar DEFAULTS = {\n  retry: 3,\n  retryDelay: function retryDelay(attemptIndex) {\n    return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n  },\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n  queryKeySerializerFn: defaultQueryKeySerializerFn,\n  queryFnParamsFilter: identity,\n  throwOnError: false,\n  useErrorBoundary: undefined,\n  // this will default to the suspense value\n  onMutate: noop,\n  onSuccess: noop,\n  onError: noop,\n  onSettled: noop,\n  refetchOnMount: true,\n  isDataEqual: deepEqual\n};\nvar defaultConfigRef = {\n  current: DEFAULTS\n};\n\nfunction useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current;\n}\n\nfunction ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var configContextValue = React.useContext(configContext);\n  var newConfig = React.useMemo(function () {\n    var newConfig = _extends({}, configContextValue || defaultConfigRef.current, config); // Default useErrorBoundary to the suspense value\n\n\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense;\n    }\n\n    return newConfig;\n  }, [config, configContextValue]);\n  React.useEffect(function () {\n    // restore previous config on unmount\n    return function () {\n      defaultConfigRef.current = _extends({}, configContextValue || DEFAULTS); // Default useErrorBoundary to the suspense value\n\n      if (typeof defaultConfigRef.current.useErrorBoundary === 'undefined') {\n        defaultConfigRef.current.useErrorBoundary = defaultConfigRef.current.suspense;\n      }\n    };\n  }, [configContextValue]);\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig;\n  }\n\n  return /*#__PURE__*/React.createElement(configContext.Provider, {\n    value: newConfig\n  }, children);\n}\n\nfunction defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return [];\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey());\n    } catch (_unused) {\n      return [];\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey];\n  }\n\n  var queryHash = stableStringify(queryKey);\n  queryKey = JSON.parse(queryHash);\n  return [queryHash, queryKey];\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nvar queryCache = makeQueryCache();\nvar queryCacheContext = React.createContext(queryCache);\nvar queryCaches = [queryCache];\n\nfunction useQueryCache() {\n  return React.useContext(queryCacheContext);\n}\n\nfunction ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n  var cache = React.useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n  React.useEffect(function () {\n    queryCaches.push(cache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(cache);\n\n      if (i >= 0) {\n        queryCaches.splice(i, 1);\n      } // if the cache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        cache.clear();\n      }\n    };\n  }, [cache, queryCache]);\n  return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {\n    value: cache\n  }, children);\n}\n\nvar actionInit = {};\nvar actionFailed = {};\nvar actionMarkStale = {};\nvar actionMarkGC = {};\nvar actionFetch = {};\nvar actionSuccess = {};\nvar actionError = {};\nvar actionSetState = {};\n\nfunction makeQueryCache() {\n  var listeners = [];\n  var cache = {\n    queries: {},\n    isFetching: 0\n  };\n\n  var notifyGlobalListeners = function notifyGlobalListeners() {\n    cache.isFetching = Object.values(cache.queries).reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    listeners.forEach(function (d) {\n      return d(cache);\n    });\n  };\n\n  cache.subscribe = function (cb) {\n    listeners.push(cb);\n    return function () {\n      listeners.splice(listeners.indexOf(cb), 1);\n    };\n  };\n\n  cache.clear = function () {\n    Object.values(cache.queries).forEach(function (query) {\n      return query.clear();\n    });\n    cache.queries = {};\n    notifyGlobalListeners();\n  };\n\n  var findQueries = function findQueries(predicate, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        exact = _ref2.exact;\n\n    if (typeof predicate !== 'function') {\n      var _defaultConfigRef$cur = defaultConfigRef.current.queryKeySerializerFn(predicate),\n          queryHash = _defaultConfigRef$cur[0],\n          queryKey = _defaultConfigRef$cur[1];\n\n      predicate = function predicate(d) {\n        return exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey);\n      };\n    }\n\n    return Object.values(cache.queries).filter(predicate);\n  };\n\n  cache.getQueries = findQueries;\n\n  cache.getQuery = function (queryKey) {\n    return findQueries(queryKey, {\n      exact: true\n    })[0];\n  };\n\n  cache.getQueryData = function (queryKey) {\n    var _cache$getQuery;\n\n    return (_cache$getQuery = cache.getQuery(queryKey)) == null ? void 0 : _cache$getQuery.state.data;\n  };\n\n  cache.removeQueries = function (predicate, _temp2) {\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        exact = _ref3.exact;\n\n    var foundQueries = findQueries(predicate, {\n      exact: exact\n    });\n    foundQueries.forEach(function (query) {\n      clearTimeout(query.staleTimeout);\n      delete cache.queries[query.queryHash];\n    });\n\n    if (foundQueries.length) {\n      notifyGlobalListeners();\n    }\n  };\n\n  cache.cancelQueries = function (predicate, _temp3) {\n    var _ref4 = _temp3 === void 0 ? {} : _temp3,\n        exact = _ref4.exact;\n\n    var foundQueries = findQueries(predicate, {\n      exact: exact\n    });\n    foundQueries.forEach(function (query) {\n      query.cancel();\n    });\n\n    if (foundQueries.length) {\n      notifyGlobalListeners();\n    }\n  };\n\n  cache.refetchQueries = _async(function (predicate, _temp4) {\n    var _ref5 = _temp4 === void 0 ? {} : _temp4,\n        exact = _ref5.exact,\n        throwOnError = _ref5.throwOnError,\n        force = _ref5.force;\n\n    var foundQueries = predicate === true ? Object.values(cache.queries) : findQueries(predicate, {\n      exact: exact\n    });\n    return _catch(function () {\n      return _await(Promise.all(foundQueries.map(function (query) {\n        return query.fetch({\n          force: force\n        });\n      })));\n    }, function (err) {\n      if (throwOnError) {\n        throw err;\n      }\n    });\n  });\n\n  cache._buildQuery = function (userQueryKey, queryVariables, queryFn, config) {\n    var _config$queryKeySeria = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _config$queryKeySeria[0],\n        queryKey = _config$queryKeySeria[1];\n\n    var query = cache.queries[queryHash];\n\n    if (query) {\n      Object.assign(query, {\n        queryVariables: queryVariables,\n        queryFn: queryFn\n      });\n      query.config = _extends({}, query.config, config);\n    } else {\n      query = makeQuery({\n        cache: cache,\n        queryKey: queryKey,\n        queryHash: queryHash,\n        queryVariables: queryVariables,\n        queryFn: queryFn,\n        config: config\n      }); // If the query started with data, schedule\n      // a stale timeout\n\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout(); // Simulate a query healing process\n\n        query.heal(); // Schedule for garbage collection in case\n        // nothing subscribes to this query\n\n        query.scheduleGarbageCollection();\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query; // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n\n          setTimeout(function () {\n            notifyGlobalListeners();\n          });\n        }\n      }\n    }\n\n    return query;\n  };\n\n  cache.prefetchQuery = _async(function () {\n    var _exit = false;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _getQueryArgs = getQueryArgs(args),\n        queryKey = _getQueryArgs[0],\n        queryVariables = _getQueryArgs[1],\n        queryFn = _getQueryArgs[2],\n        _getQueryArgs$ = _getQueryArgs[3],\n        force = _getQueryArgs$.force,\n        config = _objectWithoutPropertiesLoose(_getQueryArgs$, [\"force\"]);\n\n    config = _extends({}, defaultConfigRef.current, config);\n\n    var query = cache._buildQuery(queryKey, queryVariables, queryFn, config); // Don't prefetch queries that are fresh, unless force is passed\n\n\n    return _invoke(function () {\n      if (query.state.isStale || force) {\n        // Trigger a fetch and return the promise\n        return _catch(function () {\n          return _await(query.fetch({\n            force: force\n          }), function (res) {\n            query.wasPrefetched = true;\n            _exit = true;\n            return res;\n          });\n        }, function (err) {\n          if (config.throwOnError) {\n            throw err;\n          }\n        });\n      }\n    }, function (_result3) {\n      return _exit ? _result3 : query.state.data;\n    });\n  });\n\n  cache.setQueryData = function (queryKey, updater, _temp5) {\n    var _ref6 = _temp5 === void 0 ? {} : _temp5,\n        exact = _ref6.exact,\n        config = _objectWithoutPropertiesLoose(_ref6, [\"exact\"]);\n\n    var queries = findQueries(queryKey, {\n      exact: exact\n    });\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [cache._buildQuery(queryKey, undefined, function () {\n        return new Promise(noop);\n      }, _extends({}, defaultConfigRef.current, config))];\n    }\n\n    queries.forEach(function (d) {\n      return d.setData(updater);\n    });\n  };\n\n  function makeQuery(options) {\n    var queryCache = options.cache;\n    var reducer = options.config.queryReducer || defaultQueryReducer;\n    var noQueryHash = typeof options.queryHash === 'undefined';\n    var initialData = typeof options.config.initialData === 'function' ? options.config.initialData() : options.config.initialData;\n    var hasInitialData = typeof initialData !== 'undefined';\n    var isStale = noQueryHash ? true : !hasInitialData;\n    var manual = options.config.manual;\n    var initialStatus = noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading;\n\n    var query = _extends({}, options, {\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus: initialStatus,\n        initialData: initialData,\n        hasInitialData: hasInitialData,\n        isStale: isStale,\n        manual: manual\n      })\n    });\n\n    var dispatch = function dispatch(action) {\n      query.state = reducer(query.state, action);\n      query.instances.forEach(function (d) {\n        return d.onStateUpdate(query.state);\n      });\n      notifyGlobalListeners();\n    };\n\n    query.scheduleStaleTimeout = function () {\n      if (query.config.staleTime === Infinity) {\n        return;\n      }\n\n      query.staleTimeout = setTimeout(function () {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({\n            type: actionMarkStale\n          });\n        }\n      }, query.config.staleTime);\n    };\n\n    query.scheduleGarbageCollection = function () {\n      if (query.config.cacheTime === Infinity) {\n        return;\n      }\n\n      dispatch({\n        type: actionMarkGC\n      });\n      query.cacheTimeout = setTimeout(function () {\n        cache.removeQueries(function (d) {\n          return d.state.markedForGarbageCollection && d.queryHash === query.queryHash;\n        });\n      }, typeof query.state.data === 'undefined' && query.state.status !== 'error' ? 0 : query.config.cacheTime);\n    };\n\n    query.heal = function () {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout); // Mark the query as not cancelled\n\n      query.cancelled = null;\n    };\n\n    query.cancel = function () {\n      query.cancelled = cancelledError;\n\n      if (query.cancelPromises) {\n        query.cancelPromises();\n      }\n\n      delete query.promise;\n      notifyGlobalListeners();\n    };\n\n    query.updateInstance = function (instance) {\n      var found = query.instances.find(function (d) {\n        return d.id === instance.id;\n      });\n\n      if (found) {\n        Object.assign(found, instance);\n      } else {\n        found = _extends({\n          onStateUpdate: noop\n        }, instance);\n        query.instances.push(instance);\n      }\n    };\n\n    query.subscribe = function (instanceId) {\n      query.heal(); // Return the unsubscribe function\n\n      return function () {\n        query.instances = query.instances.filter(function (d) {\n          return d.id !== instanceId;\n        });\n\n        if (!query.instances.length) {\n          query.cancel(); // Schedule garbage collection\n\n          query.scheduleGarbageCollection();\n        }\n      };\n    }; // Set up the fetch function\n\n\n    var tryFetchData = _async(function (queryFn) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return _catch(function () {\n        // Perform the query\n        var promise = queryFn.apply(void 0, query.config.queryFnParamsFilter(args));\n\n        query.cancelPromises = function () {\n          return promise.cancel == null ? void 0 : promise.cancel();\n        };\n\n        return _await(promise, function (data) {\n          delete query.shouldContinueRetryOnFocus;\n          delete query.cancelPromises;\n          if (query.cancelled) throw query.cancelled;\n          return data;\n        });\n      }, function (error) {\n        var _exit2 = false;\n        delete query.cancelPromises;\n        if (query.cancelled) throw query.cancelled; // If we fail, increase the failureCount\n\n        dispatch({\n          type: actionFailed\n        }); // Do we need to retry the request?\n\n        return _invoke(function () {\n          if (query.config.retry === true || query.state.failureCount <= query.config.retry || typeof query.config.retry === 'function' && query.config.retry(query.state.failureCount, error)) {\n            // Only retry if the document is visible\n            if (!isDocumentVisible()) {\n              // set this flag to continue fetch retries on focus\n              query.shouldContinueRetryOnFocus = true;\n              _exit2 = true;\n              return new Promise(noop);\n            }\n\n            delete query.shouldContinueRetryOnFocus; // Determine the retryDelay\n\n            var delay = functionalUpdate(query.config.retryDelay, query.state.failureCount); // Return a new promise with the retry\n\n            _exit2 = true;\n            return _await(new Promise(function (resolve, reject) {\n              // Keep track of the retry timeout\n              setTimeout(_async(function () {\n                return query.cancelled ? reject(query.cancelled) : _catch(function () {\n                  return _await(tryFetchData.apply(void 0, [queryFn].concat(args)), function (data) {\n                    if (query.cancelled) return reject(query.cancelled);\n                    resolve(data);\n                  });\n                }, function (error) {\n                  if (query.cancelled) return reject(query.cancelled);\n                  reject(error);\n                });\n              }), delay);\n            }));\n          }\n        }, function (_result4) {\n          if (_exit2) return _result4;\n          throw error;\n        });\n      });\n    });\n\n    query.fetch = _async(function (_temp6) {\n      var _ref7 = _temp6 === void 0 ? {} : _temp6,\n          force = _ref7.force,\n          _ref7$__queryFn = _ref7.__queryFn,\n          __queryFn = _ref7$__queryFn === void 0 ? query.queryFn : _ref7$__queryFn; // Don't refetch fresh queries that don't have a queryHash\n\n\n      if (!query.queryHash || !query.state.isStale && !force) {\n        return;\n      } // Create a new promise for the query cache if necessary\n\n\n      if (!query.promise) {\n        query.promise = _async(function () {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null;\n          var callbackInstances = [].concat(query.instances);\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.suspenseInstance);\n          }\n\n          return _catch(function () {\n            // Set up the query refreshing state\n            dispatch({\n              type: actionFetch\n            }); // Try to fetch\n\n            return _await(tryFetchData.apply(void 0, [__queryFn].concat(query.queryKey, query.queryVariables)), function (data) {\n              query.setData(function (old) {\n                return query.config.isDataEqual(old, data) ? old : data;\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSuccess && instance.onSuccess(query.state.data);\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSettled && instance.onSettled(query.state.data, null);\n              });\n              delete query.promise;\n              return data;\n            });\n          }, function (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error: error\n            });\n            delete query.promise;\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(function (instance) {\n                return instance.onError && instance.onError(error);\n              });\n              callbackInstances.forEach(function (instance) {\n                return instance.onSettled && instance.onSettled(undefined, error);\n              });\n              throw error;\n            }\n          });\n        })();\n      }\n\n      return query.promise;\n    });\n\n    query.setState = function (updater) {\n      return dispatch({\n        type: actionSetState,\n        updater: updater\n      });\n    };\n\n    query.setData = function (updater) {\n      // Set data and mark it as cached\n      dispatch({\n        type: actionSuccess,\n        updater: updater\n      }); // Schedule a fresh invalidation!\n\n      clearTimeout(query.staleTimeout);\n      query.scheduleStaleTimeout();\n    };\n\n    query.clear = function () {\n      clearTimeout(query.staleTimeout);\n      clearTimeout(query.cacheTimeout);\n      query.cancel();\n    };\n\n    return query;\n  }\n\n  return cache;\n}\n\nfunction defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching: action.hasInitialData || action.manual ? false : action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0\n      };\n\n    case actionFailed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case actionMarkStale:\n      return _extends({}, state, {\n        isStale: true\n      });\n\n    case actionMarkGC:\n      {\n        return _extends({}, state, {\n          markedForGarbageCollection: true\n        });\n      }\n\n    case actionFetch:\n      return _extends({}, state, {\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0\n      });\n\n    case actionSuccess:\n      return _extends({}, state, {\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case actionError:\n      return _extends({}, state, {\n        isFetching: false,\n        isStale: true\n      }, !action.cancelled && {\n        status: statusError,\n        error: action.error\n      });\n\n    case actionSetState:\n      return functionalUpdate(action.updater, state);\n\n    default:\n      throw new Error();\n  }\n}\n\nvar visibilityChangeEvent = 'visibilitychange';\nvar focusEvent = 'focus';\n\nvar onWindowFocus = function onWindowFocus() {\n  var refetchAllOnWindowFocus = defaultConfigRef.current.refetchAllOnWindowFocus;\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      return queryCache.refetchQueries(function (query) {\n        if (!query.instances.length) {\n          return false;\n        }\n\n        if (query.config.manual === true) {\n          return false;\n        }\n\n        if (query.shouldContinueRetryOnFocus) {\n          // delete promise, so `fetch` will create new one\n          delete query.promise;\n          return true;\n        }\n\n        if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n          return refetchAllOnWindowFocus;\n        } else {\n          return query.config.refetchOnWindowFocus;\n        }\n      }).catch(Console.error);\n    });\n  }\n};\n\nvar removePreviousHandler;\n\nfunction setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler();\n  } // Sub the new watcher\n\n\n  removePreviousHandler = callback(onWindowFocus);\n}\n\nsetFocusHandler(function (handleFocus) {\n  var _window; // Listen to visibillitychange and focus\n\n\n  if (!isServer && ((_window = window) == null ? void 0 : _window.addEventListener)) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false);\n    window.addEventListener(focusEvent, handleFocus, false);\n    return function () {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus);\n      window.removeEventListener(focusEvent, handleFocus);\n    };\n  }\n});\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n\n  var _React$useState = React.useState({}),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  React.useEffect(function () {\n    return queryCache.subscribe(function () {\n      return setState({});\n    });\n  }, []);\n  return React.useMemo(function () {\n    return state && queryCache.isFetching;\n  }, [state]);\n}\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar getDefaultState = function getDefaultState() {\n  return {\n    status: statusIdle,\n    data: undefined,\n    error: null\n  };\n};\n\nfunction _empty() {}\n\nvar actionReset = {};\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nvar actionLoading = {};\n\nfunction _invoke$1(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nvar actionResolve = {};\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar actionReject = {};\n\nfunction _async$1(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState();\n  }\n\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading\n    };\n  }\n\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data\n    };\n  }\n\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error\n    };\n  }\n\n  throw new Error();\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var getConfig = useGetLatest(_extends({}, useConfigContext(), config));\n  var latestMutationRef = React.useRef();\n  var mutate = React.useCallback(_async$1(function (variables, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$onSuccess = _ref.onSuccess,\n        onSuccess = _ref$onSuccess === void 0 ? noop : _ref$onSuccess,\n        _ref$onError = _ref.onError,\n        onError = _ref$onError === void 0 ? noop : _ref$onError,\n        _ref$onSettled = _ref.onSettled,\n        onSettled = _ref$onSettled === void 0 ? noop : _ref$onSettled,\n        throwOnError = _ref.throwOnError;\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    dispatch({\n      type: actionLoading\n    });\n    var snapshotValue;\n    return _catch$1(function () {\n      return _await$1(config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        var data;\n        return _invoke$1(function () {\n          if (isLatest()) {\n            return _await$1(getMutationFn()(variables), function (_getMutationFn) {\n              data = _getMutationFn;\n            });\n          }\n        }, function () {\n          return _invoke$1(function () {\n            if (isLatest()) {\n              return _awaitIgnored(onSuccess(data, variables));\n            }\n          }, function () {\n            return _invoke$1(function () {\n              if (isLatest()) {\n                return _awaitIgnored(config.onSuccess(data, variables));\n              }\n            }, function () {\n              return _invoke$1(function () {\n                if (isLatest()) {\n                  return _awaitIgnored(onSettled(data, null, variables));\n                }\n              }, function () {\n                return _invoke$1(function () {\n                  if (isLatest()) {\n                    return _awaitIgnored(config.onSettled(data, null, variables));\n                  }\n                }, function () {\n                  if (isLatest()) {\n                    dispatch({\n                      type: actionResolve,\n                      data: data\n                    });\n                  }\n\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      return _invoke$1(function () {\n        if (isLatest()) {\n          Console.error(error);\n          return _awaitIgnored(onError(error, variables, snapshotValue));\n        }\n      }, function () {\n        return _invoke$1(function () {\n          if (isLatest()) {\n            return _awaitIgnored(config.onError(error, variables, snapshotValue));\n          }\n        }, function () {\n          return _invoke$1(function () {\n            if (isLatest()) {\n              return _awaitIgnored(onSettled(undefined, error, variables, snapshotValue));\n            }\n          }, function () {\n            return _invoke$1(function () {\n              if (isLatest()) {\n                return _awaitIgnored(config.onSettled(undefined, error, variables, snapshotValue));\n              }\n            }, function () {\n              if (isLatest()) {\n                dispatch({\n                  type: actionReject,\n                  error: error\n                });\n\n                if (throwOnError != null ? throwOnError : config.throwOnError) {\n                  throw error;\n                }\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n  var reset = React.useCallback(function () {\n    return dispatch({\n      type: actionReset\n    });\n  }, [dispatch]);\n  React.useEffect(function () {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction _await$2(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch$2(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async$2(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction useBaseQuery(queryKey, queryVariables, queryFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var instanceId = useUid();\n  config = _extends({}, useConfigContext(), config);\n  var queryCache = useQueryCache();\n  var queryRef = React.useRef();\n\n  var newQuery = queryCache._buildQuery(queryKey, queryVariables, queryFn, config);\n\n  var useCachedQuery = queryRef.current && typeof queryRef.current.queryHash === 'undefined' && typeof newQuery.queryHash === 'undefined'; // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n\n  if (!useCachedQuery) {\n    queryRef.current = newQuery;\n  }\n\n  var query = queryRef.current;\n\n  var _React$useState = React.useState(),\n      unsafeRerender = _React$useState[1];\n\n  var rerender = useMountedCallback(unsafeRerender);\n  var getLatestConfig = useGetLatest(config);\n  var refetch = React.useCallback(_async$2(function (_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        throwOnError = _ref.throwOnError,\n        rest = _objectWithoutPropertiesLoose(_ref, [\"throwOnError\"]);\n\n    return _catch$2(function () {\n      return _await$2(query.fetch(rest));\n    }, function (err) {\n      if (throwOnError) {\n        throw err;\n      }\n    });\n  }), [query]);\n  query.suspenseInstance = {\n    onSuccess: function onSuccess(data) {\n      return getLatestConfig().onSuccess(data);\n    },\n    onError: function onError(err) {\n      return getLatestConfig().onError(err);\n    },\n    onSettled: function onSettled(data, err) {\n      return getLatestConfig().onSettled(data, err);\n    }\n  }; // After mount, subscribe to the query\n\n  React.useEffect(function () {\n    // Update the instance to the query again, but not as a placeholder\n    query.updateInstance({\n      id: instanceId,\n      onStateUpdate: function onStateUpdate() {\n        return rerender({});\n      },\n      onSuccess: function onSuccess(data) {\n        return getLatestConfig().onSuccess(data);\n      },\n      onError: function onError(err) {\n        return getLatestConfig().onError(err);\n      },\n      onSettled: function onSettled(data, err) {\n        return getLatestConfig().onSettled(data, err);\n      }\n    });\n    return query.subscribe(instanceId);\n  }, [getLatestConfig, instanceId, query, rerender]);\n  React.useEffect(function () {\n    // Perform the initial fetch for this query if necessary\n    if (!getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n    !query.wasPrefetched && // Don't double fetch for prefetched queries\n    !query.wasSuspended && // Don't double fetch for suspense\n    query.state.isStale && ( // Only refetch if stale\n    getLatestConfig().refetchOnMount || query.instances.length === 1)) {\n      refetch().catch(Console.error);\n    }\n\n    query.wasPrefetched = false;\n    query.wasSuspended = false;\n  }, [getLatestConfig, query, refetch]); // Handle refetch interval\n\n  React.useEffect(function () {\n    var query = queryRef.current;\n\n    if (config.refetchInterval && (!query.currentRefetchInterval || // shorter interval should override previous one\n    config.refetchInterval < query.currentRefetchInterval)) {\n      query.currentRefetchInterval = config.refetchInterval;\n      clearInterval(query.refetchIntervalId);\n      query.refetchIntervalId = setInterval(function () {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error);\n        }\n      }, config.refetchInterval);\n      return function () {\n        clearInterval(query.refetchIntervalId);\n        delete query.refetchIntervalId;\n        delete query.currentRefetchInterval;\n      };\n    }\n  }, [config.refetchInterval, config.refetchIntervalInBackground, refetch]);\n  return _extends({}, query.state, {\n    config: config,\n    query: query,\n    refetch: refetch\n  });\n}\n\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var query = useBaseQuery.apply(void 0, getQueryArgs(args));\n  handleSuspense(query);\n  return query;\n}\n\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      queryVariables = _getQueryArgs[1],\n      queryFn = _getQueryArgs[2],\n      _getQueryArgs$ = _getQueryArgs[3],\n      config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;\n\n  var lastDataRef = React.useRef();\n\n  if (!queryKey) {\n    lastDataRef.current = undefined;\n  } // If latestData is set, don't use initialData\n\n\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData;\n  }\n\n  var query = useBaseQuery(queryKey, queryVariables, queryFn, config);\n  var latestData = query.data,\n      status = query.status;\n  React.useEffect(function () {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData;\n    }\n  }, [latestData, status]);\n  var resolvedData = latestData;\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current;\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success';\n  }\n\n  var paginatedQuery = _extends({}, query, {\n    resolvedData: resolvedData,\n    latestData: latestData,\n    status: status\n  });\n\n  handleSuspense(paginatedQuery);\n  return paginatedQuery;\n}\n\nfunction _await$3(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _empty$1() {}\n\nfunction _invokeIgnored(body) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(_empty$1);\n  }\n}\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}();\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n}\n\nfunction _do(body, test) {\n  var awaitBody;\n\n  do {\n    var result = body();\n\n    if (result && result.then) {\n      if (_isSettledPact(result)) {\n        result = result.v;\n      } else {\n        awaitBody = true;\n        break;\n      }\n    }\n\n    var shouldContinue = test();\n\n    if (_isSettledPact(shouldContinue)) {\n      shouldContinue = shouldContinue.v;\n    }\n\n    if (!shouldContinue) {\n      return result;\n    }\n  } while (!shouldContinue.then);\n\n  var pact = new _Pact();\n\n  var reject = _settle.bind(null, pact, 2);\n\n  (awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n  return pact;\n\n  function _resumeAfterBody(value) {\n    result = value;\n\n    for (;;) {\n      shouldContinue = test();\n\n      if (_isSettledPact(shouldContinue)) {\n        shouldContinue = shouldContinue.v;\n      }\n\n      if (!shouldContinue) {\n        break;\n      }\n\n      if (shouldContinue.then) {\n        shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n        return;\n      }\n\n      result = body();\n\n      if (result && result.then) {\n        if (_isSettledPact(result)) {\n          result = result.v;\n        } else {\n          result.then(_resumeAfterBody).then(void 0, reject);\n          return;\n        }\n      }\n    }\n\n    _settle(pact, 1, result);\n  }\n\n  function _resumeAfterTest(shouldContinue) {\n    if (shouldContinue) {\n      do {\n        result = body();\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_resumeAfterBody).then(void 0, reject);\n            return;\n          }\n        }\n\n        shouldContinue = test();\n\n        if (_isSettledPact(shouldContinue)) {\n          shouldContinue = shouldContinue.v;\n        }\n\n        if (!shouldContinue) {\n          _settle(pact, 1, result);\n\n          return;\n        }\n      } while (!shouldContinue.then);\n\n      shouldContinue.then(_resumeAfterTest).then(void 0, reject);\n    } else {\n      _settle(pact, 1, result);\n    }\n  }\n}\n\nfunction _continue(value, then) {\n  return value && value.then ? value.then(then) : then(value);\n}\n\nfunction _async$3(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction _rethrow(thrown, value) {\n  if (thrown) throw value;\n  return value;\n}\n\nfunction _finallyRethrows(body, finalizer) {\n  try {\n    var result = body();\n  } catch (e) {\n    return finalizer(true, e);\n  }\n\n  if (result && result.then) {\n    return result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n  }\n\n  return finalizer(false, result);\n}\n\nfunction useInfiniteQuery() {\n  var queryInfoRef = React.useRef();\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _getQueryArgs = getQueryArgs(args),\n      queryKey = _getQueryArgs[0],\n      queryVariables = _getQueryArgs[1],\n      queryFn = _getQueryArgs[2],\n      _getQueryArgs$ = _getQueryArgs[3],\n      config = _getQueryArgs$ === void 0 ? {} : _getQueryArgs$;\n\n  var getFetchMore = config.getFetchMore;\n  var getGetFetchMore = useGetLatest(getFetchMore); // The default queryFn will query all pages and map them together\n\n  var originalQueryFn = queryFn;\n  queryFn = _async$3(function () {\n    var _interrupt = false;\n    var data = [];\n    var pageVariables = [].concat(queryInfoRef.current.query.pageVariables);\n    var rebuiltPageVariables = [];\n    return _continue(_do(function () {\n      var args = pageVariables.shift();\n      return _invokeIgnored(function () {\n        if (!data.length) {\n          var _push3 = data.push; // the first page query doesn't need to be rebuilt\n\n          return _await$3(originalQueryFn.apply(void 0, args), function (_originalQueryFn) {\n            _push3.call(data, _originalQueryFn);\n\n            rebuiltPageVariables.push(args);\n          });\n        } else {\n          // get an up-to-date cursor based on the previous data set\n          var nextCursor = getGetFetchMore()(data[data.length - 1], data); // break early if there's no next cursor\n          // otherwise we'll start from the beginning\n          // which will cause unwanted duplication\n\n          if (!nextCursor) {\n            _interrupt = true;\n            return;\n          }\n\n          var pageArgs = [].concat(args.slice(0, -1), [nextCursor]);\n          var _push4 = data.push;\n          return _await$3(originalQueryFn.apply(void 0, pageArgs), function (_originalQueryFn2) {\n            _push4.call(data, _originalQueryFn2);\n\n            rebuiltPageVariables.push(pageArgs);\n          });\n        }\n      });\n    }, function () {\n      return !_interrupt && !!pageVariables.length;\n    }), function () {\n      queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);\n      queryInfoRef.current.query.pageVariables = rebuiltPageVariables;\n      return data;\n    });\n  });\n  var queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config);\n\n  if (typeof queryInfo.query.canFetchMore === 'undefined' && typeof queryInfo.data !== 'undefined') {\n    queryInfo.query.canFetchMore = getGetFetchMore()(queryInfo.data[queryInfo.data.length - 1], queryInfo.data);\n  }\n\n  queryInfoRef.current = queryInfo;\n  var refetch = queryInfo.refetch,\n      _queryInfo$data = queryInfo.data,\n      data = _queryInfo$data === void 0 ? [] : _queryInfo$data,\n      canFetchMore = queryInfo.query.canFetchMore; // Here we seed the pageVariabes for the query\n\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [[].concat(queryInfo.query.queryKey, queryInfo.query.queryVariables)];\n  }\n\n  var fetchMore = React.useCallback(function (fetchMoreInfo) {\n    if (fetchMoreInfo === void 0) {\n      fetchMoreInfo = queryInfoRef.current.query.canFetchMore;\n    }\n\n    return queryInfoRef.current.query.canFetchMore ? refetch({\n      force: true,\n      __queryFn: _async$3(function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return _finallyRethrows(function () {\n          queryInfoRef.current.query.setState(function (old) {\n            return _extends({}, old, {\n              isFetchingMore: true\n            });\n          });\n          var newArgs = [].concat(args, [fetchMoreInfo]);\n          queryInfoRef.current.query.pageVariables.push(newArgs);\n          var _queryInfoRef$current = queryInfoRef.current.data;\n          return _await$3(originalQueryFn.apply(void 0, newArgs), function (_originalQueryFn3) {\n            var data = [].concat(_queryInfoRef$current, [_originalQueryFn3]);\n            queryInfoRef.current.query.canFetchMore = getGetFetchMore()(data[data.length - 1], data);\n            return data;\n          });\n        }, function (_wasThrown, _result) {\n          queryInfoRef.current.query.setState(function (old) {\n            return _extends({}, old, {\n              isFetchingMore: false\n            });\n          });\n          return _rethrow(_wasThrown, _result);\n        });\n      })\n    }) : void 0;\n  }, [getGetFetchMore, originalQueryFn, refetch]);\n  handleSuspense(queryInfo);\n  return _extends({}, queryInfo, {\n    data: data,\n    canFetchMore: canFetchMore,\n    fetchMore: fetchMore\n  });\n}\n\nexport { ReactQueryCacheProvider, ReactQueryConfigProvider, deepIncludes, makeQueryCache, queryCache, setConsole, setFocusHandler, stableStringify, statusError, statusIdle, statusLoading, statusSuccess, useInfiniteQuery, useIsFetching, useMutation, usePaginatedQuery, useQuery, useQueryCache };","map":{"version":3,"mappings":"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","names":["statusIdle","statusLoading","statusError","statusSuccess","_uid","uid","cancelledError","isServer","window","noop","identity","d","Console","console","error","warn","log","useUid","ref","React","useRef","current","setConsole","c","useGetLatest","obj","useCallback","functionalUpdate","updater","old","stableStringifyReplacer","_","value","isObject","Object","assign","keys","sort","map","key","stableStringify","JSON","stringify","a","Array","isArray","deepIncludes","b","some","isDocumentVisible","document","visibilityState","undefined","isOnline","navigator","onLine","getQueryArgs","args","hasOwnProperty","queryKey","variables","queryFn","config","Error","useMountedCallback","callback","mounted","handleSuspense","queryInfo","suspense","useErrorBoundary","status","setTimeout","query","state","wasSuspended","refetch","deepEqual","length","i","valueOf","prototype","call","configContext","createContext","DEFAULTS","retry","retryDelay","Math","min","attemptIndex","staleTime","cacheTime","refetchAllOnWindowFocus","refetchInterval","queryKeySerializerFn","defaultQueryKeySerializerFn","queryFnParamsFilter","throwOnError","onMutate","onSuccess","onError","onSettled","refetchOnMount","isDataEqual","defaultConfigRef","useConfigContext","useContext","ReactQueryConfigProvider","children","configContextValue","newConfig","useMemo","useEffect","Provider","queryHash","parse","then","direct","Promise","resolve","body","recover","result","e","f","arguments","apply","reject","queryCache","makeQueryCache","queryCacheContext","queryCaches","useQueryCache","ReactQueryCacheProvider","cache","push","indexOf","splice","clear","actionInit","actionFailed","actionMarkStale","actionMarkGC","actionFetch","actionSuccess","actionError","actionSetState","listeners","queries","isFetching","notifyGlobalListeners","values","reduce","acc","forEach","subscribe","cb","findQueries","predicate","exact","filter","getQueries","getQuery","getQueryData","_cache$getQuery","data","removeQueries","foundQueries","clearTimeout","staleTimeout","cancelQueries","cancel","refetchQueries","force","all","fetch","err","_buildQuery","userQueryKey","queryVariables","makeQuery","scheduleStaleTimeout","heal","scheduleGarbageCollection","prefetchQuery","isStale","res","wasPrefetched","_exit","setQueryData","setData","options","reducer","queryReducer","defaultQueryReducer","noQueryHash","initialData","hasInitialData","manual","initialStatus","instances","type","dispatch","action","onStateUpdate","Infinity","cacheTimeout","markedForGarbageCollection","cancelled","cancelPromises","promise","updateInstance","found","find","id","instance","instanceId","tryFetchData","shouldContinueRetryOnFocus","failureCount","_exit2","delay","_catch","__queryFn","_async","callbackInstances","unshift","suspenseInstance","setState","canFetchMore","updatedAt","Date","now","visibilityChangeEvent","focusEvent","onWindowFocus","refetchOnWindowFocus","catch","removePreviousHandler","setFocusHandler","_window","addEventListener","handleFocus","removeEventListener","useIsFetching","useState","_await","getDefaultState","_empty","actionReset","_awaitIgnored","actionLoading","_invoke","actionResolve","actionReject","mutationReducer","useMutation","mutationFn","useReducer","unsafeDispatch","getMutationFn","getConfig","latestMutationRef","mutate","mutationId","isLatest","snapshotValue","reset","useBaseQuery","queryRef","newQuery","useCachedQuery","unsafeRerender","rerender","getLatestConfig","rest","currentRefetchInterval","clearInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","useQuery","usePaginatedQuery","lastDataRef","latestData","resolvedData","paginatedQuery","pact","s","v","o","_settle","bind","observer","_Pact","onFulfilled","onRejected","_this","thenable","test","awaitBody","_isSettledPact","shouldContinue","_resumeAfterBody","_resumeAfterTest","thrown","finalizer","useInfiniteQuery","queryInfoRef","getFetchMore","getGetFetchMore","originalQueryFn","pageVariables","rebuiltPageVariables","shift","_push3","_originalQueryFn","nextCursor","_interrupt","pageArgs","slice","_push4","_originalQueryFn2","fetchMore","fetchMoreInfo","isFetchingMore","newArgs"],"sources":["D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\utils.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\config.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\queryCache.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\setFocusHandler.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\useIsFetching.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\useMutation.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\useBaseQuery.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\useQuery.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\usePaginatedQuery.js","D:\\Open source\\pagination-app\\node_modules\\react-query\\src\\useInfiniteQuery.js"],"sourcesContent":["import React from 'react'\n\n//\n\nexport const statusIdle = 'idle'\nexport const statusLoading = 'loading'\nexport const statusError = 'error'\nexport const statusSuccess = 'success'\n\nlet _uid = 0\nexport const uid = () => _uid++\nexport const cancelledError = {}\nexport let globalStateListeners = []\nexport const isServer = typeof window === 'undefined'\nexport const noop = () => {}\nexport const identity = d => d\nexport let Console = console || { error: noop, warn: noop, log: noop }\n\nexport function useUid() {\n  const ref = React.useRef(null)\n\n  if (ref.current === null) {\n    ref.current = uid()\n  }\n\n  return ref.current\n}\n\nexport function setConsole(c) {\n  Console = c\n}\n\nexport function useGetLatest(obj) {\n  const ref = React.useRef()\n  ref.current = obj\n\n  return React.useCallback(() => ref.current, [])\n}\n\nexport function functionalUpdate(updater, old) {\n  return typeof updater === 'function' ? updater(old) : updater\n}\n\nexport function stableStringifyReplacer(_, value) {\n  return isObject(value)\n    ? Object.assign(\n        {},\n        ...Object.keys(value)\n          .sort()\n          .map(key => ({\n            [key]: value[key],\n          }))\n      )\n    : value\n}\n\nexport function stableStringify(obj) {\n  return JSON.stringify(obj, stableStringifyReplacer)\n}\n\nexport function isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\nexport function deepIncludes(a, b) {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible() {\n  return (\n    typeof document === 'undefined' ||\n    document.visibilityState === undefined ||\n    document.visibilityState === 'visible' ||\n    document.visibilityState === 'prerender'\n  )\n}\n\nexport function isOnline() {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs(args) {\n  if (isObject(args[0])) {\n    if (\n      args[0].hasOwnProperty('queryKey') &&\n      args[0].hasOwnProperty('queryFn')\n    ) {\n      const { queryKey, variables = [], queryFn, config = {} } = args[0]\n      return [queryKey, variables, queryFn, config]\n    } else {\n      throw new Error('queryKey and queryFn keys are required.')\n    }\n  }\n\n  if (typeof args[2] === 'function') {\n    const [queryKey, variables = [], queryFn, config = {}] = args\n    return [queryKey, variables, queryFn, config]\n  }\n\n  const [queryKey, queryFn, config = {}] = args\n\n  return [queryKey, [], queryFn, config]\n}\n\nexport function useMountedCallback(callback) {\n  const mounted = React.useRef(false)\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mounted.current = true\n    return () => (mounted.current = false)\n  }, [])\n  return React.useCallback(\n    (...args) => (mounted.current ? callback(...args) : void 0),\n    [callback]\n  )\n}\n\nexport function handleSuspense(queryInfo) {\n  if (queryInfo.config.suspense || queryInfo.config.useErrorBoundary) {\n    if (queryInfo.status === statusError) {\n      setTimeout(() => {\n        queryInfo.query.state.status = 'loading'\n      })\n      throw queryInfo.error\n    }\n  }\n\n  if (queryInfo.config.suspense) {\n    if (queryInfo.status === statusLoading) {\n      queryInfo.query.wasSuspended = true\n      throw queryInfo.refetch()\n    }\n  }\n}\n\n// This deep-equal is directly based on https://github.com/epoberezkin/fast-deep-equal.\n// The parts for comparing any non-JSON-supported values has been removed\nexport function deepEqual(a, b) {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      // eslint-disable-next-line eqeqeq\n      if (length != b.length) return false\n      for (i = length; i-- !== 0; ) if (!deepEqual(a[i], b[i])) return false\n      return true\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    for (i = length; i-- !== 0; ) {\n      var key = keys[i]\n\n      if (!deepEqual(a[key], b[key])) return false\n    }\n\n    return true\n  }\n\n  // true if both NaN, false otherwise\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n","import React from 'react'\nimport { noop, stableStringify, identity, deepEqual } from './utils'\n\nexport const configContext = React.createContext()\n\nconst DEFAULTS = {\n  retry: 3,\n  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  staleTime: 0,\n  cacheTime: 5 * 60 * 1000,\n  refetchAllOnWindowFocus: true,\n  refetchInterval: false,\n  suspense: false,\n  queryKeySerializerFn: defaultQueryKeySerializerFn,\n  queryFnParamsFilter: identity,\n  throwOnError: false,\n  useErrorBoundary: undefined, // this will default to the suspense value\n  onMutate: noop,\n  onSuccess: noop,\n  onError: noop,\n  onSettled: noop,\n  refetchOnMount: true,\n  isDataEqual: deepEqual,\n}\n\nexport const defaultConfigRef = {\n  current: DEFAULTS,\n}\n\nexport function useConfigContext() {\n  return React.useContext(configContext) || defaultConfigRef.current\n}\n\nexport function ReactQueryConfigProvider({ config, children }) {\n  let configContextValue = React.useContext(configContext)\n\n  const newConfig = React.useMemo(() => {\n    const newConfig = {\n      ...(configContextValue || defaultConfigRef.current),\n      ...config,\n    }\n\n    // Default useErrorBoundary to the suspense value\n    if (typeof newConfig.useErrorBoundary === 'undefined') {\n      newConfig.useErrorBoundary = newConfig.suspense\n    }\n\n    return newConfig\n  }, [config, configContextValue])\n\n  React.useEffect(() => {\n    // restore previous config on unmount\n    return () => {\n      defaultConfigRef.current = { ...(configContextValue || DEFAULTS) }\n\n      // Default useErrorBoundary to the suspense value\n      if (typeof defaultConfigRef.current.useErrorBoundary === 'undefined') {\n        defaultConfigRef.current.useErrorBoundary =\n          defaultConfigRef.current.suspense\n      }\n    }\n  }, [configContextValue])\n\n  if (!configContextValue) {\n    defaultConfigRef.current = newConfig\n  }\n\n  return (\n    <configContext.Provider value={newConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n\nexport function defaultQueryKeySerializerFn(queryKey) {\n  if (!queryKey) {\n    return []\n  }\n\n  if (typeof queryKey === 'function') {\n    try {\n      return defaultQueryKeySerializerFn(queryKey())\n    } catch {\n      return []\n    }\n  }\n\n  if (typeof queryKey === 'string') {\n    queryKey = [queryKey]\n  }\n\n  const queryHash = stableStringify(queryKey)\n  queryKey = JSON.parse(queryHash)\n\n  return [queryHash, queryKey]\n}\n","import React from 'react'\nimport {\n  isServer,\n  functionalUpdate,\n  cancelledError,\n  isDocumentVisible,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  getQueryArgs,\n  deepIncludes,\n  noop,\n} from './utils'\nimport { defaultConfigRef } from './config'\n\nexport const queryCache = makeQueryCache()\n\nexport const queryCacheContext = React.createContext(queryCache)\n\nexport const queryCaches = [queryCache]\n\nexport function useQueryCache() {\n  return React.useContext(queryCacheContext)\n}\n\nexport function ReactQueryCacheProvider({ queryCache, children }) {\n  const cache = React.useMemo(() => queryCache || makeQueryCache(), [\n    queryCache,\n  ])\n\n  React.useEffect(() => {\n    queryCaches.push(cache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(cache)\n      if (i >= 0) {\n        queryCaches.splice(i, 1)\n      }\n      // if the cache was created by us, we need to tear it down\n      if (queryCache == null) {\n        cache.clear()\n      }\n    }\n  }, [cache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={cache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n\nconst actionInit = {}\nconst actionFailed = {}\nconst actionMarkStale = {}\nconst actionMarkGC = {}\nconst actionFetch = {}\nconst actionSuccess = {}\nconst actionError = {}\nconst actionSetState = {}\n\nexport function makeQueryCache() {\n  const listeners = []\n\n  const cache = {\n    queries: {},\n    isFetching: 0,\n  }\n\n  const notifyGlobalListeners = () => {\n    cache.isFetching = Object.values(cache.queries).reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n    listeners.forEach(d => d(cache))\n  }\n\n  cache.subscribe = cb => {\n    listeners.push(cb)\n    return () => {\n      listeners.splice(listeners.indexOf(cb), 1)\n    }\n  }\n\n  cache.clear = () => {\n    Object.values(cache.queries).forEach(query => query.clear())\n    cache.queries = {}\n    notifyGlobalListeners()\n  }\n\n  const findQueries = (predicate, { exact } = {}) => {\n    if (typeof predicate !== 'function') {\n      const [\n        queryHash,\n        queryKey,\n      ] = defaultConfigRef.current.queryKeySerializerFn(predicate)\n      predicate = d =>\n        exact ? d.queryHash === queryHash : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return Object.values(cache.queries).filter(predicate)\n  }\n\n  cache.getQueries = findQueries\n\n  cache.getQuery = queryKey => findQueries(queryKey, { exact: true })[0]\n\n  cache.getQueryData = queryKey => cache.getQuery(queryKey)?.state.data\n\n  cache.removeQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      clearTimeout(query.staleTimeout)\n      delete cache.queries[query.queryHash]\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.cancelQueries = (predicate, { exact } = {}) => {\n    const foundQueries = findQueries(predicate, { exact })\n\n    foundQueries.forEach(query => {\n      query.cancel()\n    })\n\n    if (foundQueries.length) {\n      notifyGlobalListeners()\n    }\n  }\n\n  cache.refetchQueries = async (\n    predicate,\n    { exact, throwOnError, force } = {}\n  ) => {\n    const foundQueries =\n      predicate === true\n        ? Object.values(cache.queries)\n        : findQueries(predicate, { exact })\n\n    try {\n      return await Promise.all(\n        foundQueries.map(query => query.fetch({ force }))\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  cache._buildQuery = (userQueryKey, queryVariables, queryFn, config) => {\n    let [queryHash, queryKey] = config.queryKeySerializerFn(userQueryKey)\n\n    let query = cache.queries[queryHash]\n\n    if (query) {\n      Object.assign(query, { queryVariables, queryFn })\n      query.config = { ...query.config, ...config }\n    } else {\n      query = makeQuery({\n        cache,\n        queryKey,\n        queryHash,\n        queryVariables,\n        queryFn,\n        config,\n      })\n\n      // If the query started with data, schedule\n      // a stale timeout\n      if (!isServer && query.state.data) {\n        query.scheduleStaleTimeout()\n\n        // Simulate a query healing process\n        query.heal()\n        // Schedule for garbage collection in case\n        // nothing subscribes to this query\n        query.scheduleGarbageCollection()\n      }\n\n      if (query.queryHash) {\n        if (!isServer) {\n          cache.queries[queryHash] = query\n          // Here, we setTimeout so as to not trigger\n          // any setState's in parent components in the\n          // middle of the render phase.\n          setTimeout(() => {\n            notifyGlobalListeners()\n          })\n        }\n      }\n    }\n\n    return query\n  }\n\n  cache.prefetchQuery = async (...args) => {\n    let [\n      queryKey,\n      queryVariables,\n      queryFn,\n      { force, ...config },\n    ] = getQueryArgs(args)\n\n    config = {\n      ...defaultConfigRef.current,\n      ...config,\n    }\n\n    const query = cache._buildQuery(queryKey, queryVariables, queryFn, config)\n\n    // Don't prefetch queries that are fresh, unless force is passed\n    if (query.state.isStale || force) {\n      // Trigger a fetch and return the promise\n      try {\n        const res = await query.fetch({ force })\n        query.wasPrefetched = true\n        return res\n      } catch (err) {\n        if (config.throwOnError) {\n          throw err\n        }\n      }\n    }\n\n    return query.state.data\n  }\n\n  cache.setQueryData = (queryKey, updater, { exact, ...config } = {}) => {\n    let queries = findQueries(queryKey, { exact })\n\n    if (!queries.length && typeof queryKey !== 'function') {\n      queries = [\n        cache._buildQuery(queryKey, undefined, () => new Promise(noop), {\n          ...defaultConfigRef.current,\n          ...config,\n        }),\n      ]\n    }\n\n    queries.forEach(d => d.setData(updater))\n  }\n\n  function makeQuery(options) {\n    const queryCache = options.cache\n    const reducer = options.config.queryReducer || defaultQueryReducer\n\n    const noQueryHash = typeof options.queryHash === 'undefined'\n\n    const initialData =\n      typeof options.config.initialData === 'function'\n        ? options.config.initialData()\n        : options.config.initialData\n\n    const hasInitialData = typeof initialData !== 'undefined'\n\n    const isStale = noQueryHash ? true : !hasInitialData\n\n    const manual = options.config.manual\n\n    const initialStatus =\n      noQueryHash || manual || hasInitialData ? statusSuccess : statusLoading\n\n    const query = {\n      ...options,\n      instances: [],\n      state: reducer(undefined, {\n        type: actionInit,\n        initialStatus,\n        initialData,\n        hasInitialData,\n        isStale,\n        manual,\n      }),\n    }\n\n    const dispatch = action => {\n      query.state = reducer(query.state, action)\n      query.instances.forEach(d => d.onStateUpdate(query.state))\n      notifyGlobalListeners()\n    }\n\n    query.scheduleStaleTimeout = () => {\n      if (query.config.staleTime === Infinity) {\n        return\n      }\n      query.staleTimeout = setTimeout(() => {\n        if (queryCache.getQuery(query.queryKey)) {\n          dispatch({ type: actionMarkStale })\n        }\n      }, query.config.staleTime)\n    }\n\n    query.scheduleGarbageCollection = () => {\n      if (query.config.cacheTime === Infinity) {\n        return\n      }\n      dispatch({ type: actionMarkGC })\n      query.cacheTimeout = setTimeout(\n        () => {\n          cache.removeQueries(\n            d =>\n              d.state.markedForGarbageCollection &&\n              d.queryHash === query.queryHash\n          )\n        },\n        typeof query.state.data === 'undefined' &&\n          query.state.status !== 'error'\n          ? 0\n          : query.config.cacheTime\n      )\n    }\n\n    query.heal = () => {\n      // Stop the query from being garbage collected\n      clearTimeout(query.cacheTimeout)\n\n      // Mark the query as not cancelled\n      query.cancelled = null\n    }\n\n    query.cancel = () => {\n      query.cancelled = cancelledError\n\n      if (query.cancelPromises) {\n        query.cancelPromises()\n      }\n\n      delete query.promise\n\n      notifyGlobalListeners()\n    }\n\n    query.updateInstance = instance => {\n      let found = query.instances.find(d => d.id === instance.id)\n\n      if (found) {\n        Object.assign(found, instance)\n      } else {\n        found = {\n          onStateUpdate: noop,\n          ...instance,\n        }\n        query.instances.push(instance)\n      }\n    }\n\n    query.subscribe = instanceId => {\n      query.heal()\n\n      // Return the unsubscribe function\n      return () => {\n        query.instances = query.instances.filter(d => d.id !== instanceId)\n\n        if (!query.instances.length) {\n          query.cancel()\n\n          // Schedule garbage collection\n          query.scheduleGarbageCollection()\n        }\n      }\n    }\n\n    // Set up the fetch function\n    const tryFetchData = async (queryFn, ...args) => {\n      try {\n        // Perform the query\n        const promise = queryFn(...query.config.queryFnParamsFilter(args))\n\n        query.cancelPromises = () => promise.cancel?.()\n\n        const data = await promise\n        delete query.shouldContinueRetryOnFocus\n\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        return data\n      } catch (error) {\n        delete query.cancelPromises\n        if (query.cancelled) throw query.cancelled\n\n        // If we fail, increase the failureCount\n        dispatch({ type: actionFailed })\n\n        // Do we need to retry the request?\n        if (\n          query.config.retry === true ||\n          query.state.failureCount <= query.config.retry ||\n          (typeof query.config.retry === 'function' &&\n            query.config.retry(query.state.failureCount, error))\n        ) {\n          // Only retry if the document is visible\n          if (!isDocumentVisible()) {\n            // set this flag to continue fetch retries on focus\n            query.shouldContinueRetryOnFocus = true\n            return new Promise(noop)\n          }\n\n          delete query.shouldContinueRetryOnFocus\n\n          // Determine the retryDelay\n          const delay = functionalUpdate(\n            query.config.retryDelay,\n            query.state.failureCount\n          )\n\n          // Return a new promise with the retry\n          return await new Promise((resolve, reject) => {\n            // Keep track of the retry timeout\n            setTimeout(async () => {\n              if (query.cancelled) return reject(query.cancelled)\n\n              try {\n                const data = await tryFetchData(queryFn, ...args)\n                if (query.cancelled) return reject(query.cancelled)\n                resolve(data)\n              } catch (error) {\n                if (query.cancelled) return reject(query.cancelled)\n                reject(error)\n              }\n            }, delay)\n          })\n        }\n\n        throw error\n      }\n    }\n\n    query.fetch = async ({ force, __queryFn = query.queryFn } = {}) => {\n      // Don't refetch fresh queries that don't have a queryHash\n\n      if (!query.queryHash || (!query.state.isStale && !force)) {\n        return\n      }\n\n      // Create a new promise for the query cache if necessary\n      if (!query.promise) {\n        query.promise = (async () => {\n          // If there are any retries pending for this query, kill them\n          query.cancelled = null\n\n          const callbackInstances = [...query.instances]\n\n          if (query.wasSuspended) {\n            callbackInstances.unshift(query.suspenseInstance)\n          }\n\n          try {\n            // Set up the query refreshing state\n            dispatch({ type: actionFetch })\n\n            // Try to fetch\n            let data = await tryFetchData(\n              __queryFn,\n              ...query.queryKey,\n              ...query.queryVariables\n            )\n\n            query.setData(old =>\n              query.config.isDataEqual(old, data) ? old : data\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSuccess && instance.onSuccess(query.state.data)\n            )\n\n            callbackInstances.forEach(\n              instance =>\n                instance.onSettled && instance.onSettled(query.state.data, null)\n            )\n\n            delete query.promise\n\n            return data\n          } catch (error) {\n            dispatch({\n              type: actionError,\n              cancelled: error === query.cancelled,\n              error,\n            })\n\n            delete query.promise\n\n            if (error !== query.cancelled) {\n              callbackInstances.forEach(\n                instance => instance.onError && instance.onError(error)\n              )\n\n              callbackInstances.forEach(\n                instance =>\n                  instance.onSettled && instance.onSettled(undefined, error)\n              )\n\n              throw error\n            }\n          }\n        })()\n      }\n\n      return query.promise\n    }\n\n    query.setState = updater => dispatch({ type: actionSetState, updater })\n\n    query.setData = updater => {\n      // Set data and mark it as cached\n      dispatch({ type: actionSuccess, updater })\n\n      // Schedule a fresh invalidation!\n      clearTimeout(query.staleTimeout)\n      query.scheduleStaleTimeout()\n    }\n\n    query.clear = () => {\n      clearTimeout(query.staleTimeout)\n      clearTimeout(query.cacheTimeout)\n      query.cancel()\n    }\n\n    return query\n  }\n\n  return cache\n}\n\nexport function defaultQueryReducer(state, action) {\n  switch (action.type) {\n    case actionInit:\n      return {\n        status: action.initialStatus,\n        error: null,\n        isFetching:\n          action.hasInitialData || action.manual\n            ? false\n            : action.initialStatus === 'loading',\n        canFetchMore: false,\n        failureCount: 0,\n        isStale: action.isStale,\n        markedForGarbageCollection: false,\n        data: action.initialData,\n        updatedAt: action.hasInitialData ? Date.now() : 0,\n      }\n    case actionFailed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case actionMarkStale:\n      return {\n        ...state,\n        isStale: true,\n      }\n    case actionMarkGC: {\n      return {\n        ...state,\n        markedForGarbageCollection: true,\n      }\n    }\n    case actionFetch:\n      return {\n        ...state,\n        status: state.status === statusError ? statusLoading : state.status,\n        isFetching: true,\n        failureCount: 0,\n      }\n    case actionSuccess:\n      return {\n        ...state,\n        status: statusSuccess,\n        data: functionalUpdate(action.updater, state.data),\n        error: null,\n        isStale: false,\n        isFetching: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case actionError:\n      return {\n        ...state,\n        isFetching: false,\n        isStale: true,\n        ...(!action.cancelled && {\n          status: statusError,\n          error: action.error,\n        }),\n      }\n    case actionSetState:\n      return functionalUpdate(action.updater, state)\n    default:\n      throw new Error()\n  }\n}\n","import { isOnline, isDocumentVisible, Console, isServer } from './utils'\nimport { defaultConfigRef } from './config'\nimport { queryCaches } from './queryCache'\n\nconst visibilityChangeEvent = 'visibilitychange'\nconst focusEvent = 'focus'\n\nconst onWindowFocus = () => {\n  const { refetchAllOnWindowFocus } = defaultConfigRef.current\n\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache =>\n      queryCache\n        .refetchQueries(query => {\n          if (!query.instances.length) {\n            return false\n          }\n\n          if (query.config.manual === true) {\n            return false\n          }\n\n          if (query.shouldContinueRetryOnFocus) {\n            // delete promise, so `fetch` will create new one\n            delete query.promise\n            return true\n          }\n\n          if (typeof query.config.refetchOnWindowFocus === 'undefined') {\n            return refetchAllOnWindowFocus\n          } else {\n            return query.config.refetchOnWindowFocus\n          }\n        })\n        .catch(Console.error)\n    )\n  }\n}\n\nlet removePreviousHandler\n\nexport function setFocusHandler(callback) {\n  // Unsub the old watcher\n  if (removePreviousHandler) {\n    removePreviousHandler()\n  }\n  // Sub the new watcher\n  removePreviousHandler = callback(onWindowFocus)\n}\n\nsetFocusHandler(handleFocus => {\n  // Listen to visibillitychange and focus\n  if (!isServer && window?.addEventListener) {\n    window.addEventListener(visibilityChangeEvent, handleFocus, false)\n    window.addEventListener(focusEvent, handleFocus, false)\n\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener(visibilityChangeEvent, handleFocus)\n      window.removeEventListener(focusEvent, handleFocus)\n    }\n  }\n})\n","import React from 'react'\n\nimport { useQueryCache } from './queryCache'\n\nexport function useIsFetching() {\n  const queryCache = useQueryCache()\n  const [state, setState] = React.useState({})\n\n  React.useEffect(() => {\n    return queryCache.subscribe(() => setState({}))\n  }, [])\n\n  return React.useMemo(() => state && queryCache.isFetching, [state])\n}\n","import React from 'react'\n\n//\n\nimport { useConfigContext } from './config'\nimport {\n  statusIdle,\n  statusLoading,\n  statusSuccess,\n  statusError,\n  useGetLatest,\n  Console,\n  uid,\n  useMountedCallback,\n  noop,\n} from './utils'\n\nconst getDefaultState = () => ({\n  status: statusIdle,\n  data: undefined,\n  error: null,\n})\n\nconst actionReset = {}\nconst actionLoading = {}\nconst actionResolve = {}\nconst actionReject = {}\n\nfunction mutationReducer(state, action) {\n  if (action.type === actionReset) {\n    return getDefaultState()\n  }\n  if (action.type === actionLoading) {\n    return {\n      status: statusLoading,\n    }\n  }\n  if (action.type === actionResolve) {\n    return {\n      status: statusSuccess,\n      data: action.data,\n    }\n  }\n  if (action.type === actionReject) {\n    return {\n      status: statusError,\n      error: action.error,\n    }\n  }\n  throw new Error()\n}\n\nexport function useMutation(mutationFn, config = {}) {\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const getConfig = useGetLatest({\n    ...useConfigContext(),\n    ...config,\n  })\n\n  const latestMutationRef = React.useRef()\n\n  const mutate = React.useCallback(\n    async (\n      variables,\n      { onSuccess = noop, onError = noop, onSettled = noop, throwOnError } = {}\n    ) => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      dispatch({ type: actionLoading })\n\n      let snapshotValue\n\n      try {\n        snapshotValue = await config.onMutate(variables)\n\n        let data\n\n        if (isLatest()) {\n          data = await getMutationFn()(variables)\n        }\n\n        if (isLatest()) {\n          await onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSuccess(data, variables)\n        }\n\n        if (isLatest()) {\n          await onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(data, null, variables)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionResolve, data })\n        }\n\n        return data\n      } catch (error) {\n        if (isLatest()) {\n          Console.error(error)\n          await onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onError(error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          await config.onSettled(undefined, error, variables, snapshotValue)\n        }\n\n        if (isLatest()) {\n          dispatch({ type: actionReject, error })\n\n          if (throwOnError ?? config.throwOnError) {\n            throw error\n          }\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => dispatch({ type: actionReset }), [\n    dispatch,\n  ])\n\n  React.useEffect(() => {\n    if (getConfig().useErrorBoundary && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\n//\n\nimport { useQueryCache } from './queryCache'\nimport { useConfigContext } from './config'\nimport {\n  useUid,\n  isDocumentVisible,\n  Console,\n  useGetLatest,\n  useMountedCallback,\n} from './utils'\n\nexport function useBaseQuery(queryKey, queryVariables, queryFn, config = {}) {\n  const instanceId = useUid()\n\n  config = {\n    ...useConfigContext(),\n    ...config,\n  }\n\n  const queryCache = useQueryCache()\n\n  const queryRef = React.useRef()\n\n  const newQuery = queryCache._buildQuery(\n    queryKey,\n    queryVariables,\n    queryFn,\n    config\n  )\n\n  const useCachedQuery =\n    queryRef.current &&\n    typeof queryRef.current.queryHash === 'undefined' &&\n    typeof newQuery.queryHash === 'undefined'\n\n  // Do not use new query with undefined queryHash, if previous query also had undefined queryHash.\n  // Otherwise this will cause infinite loop.\n  if (!useCachedQuery) {\n    queryRef.current = newQuery\n  }\n\n  const query = queryRef.current\n\n  const [, unsafeRerender] = React.useState()\n\n  const rerender = useMountedCallback(unsafeRerender)\n\n  const getLatestConfig = useGetLatest(config)\n  const refetch = React.useCallback(\n    async ({ throwOnError, ...rest } = {}) => {\n      try {\n        return await query.fetch(rest)\n      } catch (err) {\n        if (throwOnError) {\n          throw err\n        }\n      }\n    },\n    [query]\n  )\n\n  query.suspenseInstance = {\n    onSuccess: data => getLatestConfig().onSuccess(data),\n    onError: err => getLatestConfig().onError(err),\n    onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n  }\n\n  // After mount, subscribe to the query\n  React.useEffect(() => {\n    // Update the instance to the query again, but not as a placeholder\n    query.updateInstance({\n      id: instanceId,\n      onStateUpdate: () => rerender({}),\n      onSuccess: data => getLatestConfig().onSuccess(data),\n      onError: err => getLatestConfig().onError(err),\n      onSettled: (data, err) => getLatestConfig().onSettled(data, err),\n    })\n\n    return query.subscribe(instanceId)\n  }, [getLatestConfig, instanceId, query, rerender])\n\n  React.useEffect(() => {\n    // Perform the initial fetch for this query if necessary\n    if (\n      !getLatestConfig().manual && // Don't auto fetch if config is set to manual query\n      !query.wasPrefetched && // Don't double fetch for prefetched queries\n      !query.wasSuspended && // Don't double fetch for suspense\n      query.state.isStale && // Only refetch if stale\n      (getLatestConfig().refetchOnMount || query.instances.length === 1)\n    ) {\n      refetch().catch(Console.error)\n    }\n\n    query.wasPrefetched = false\n    query.wasSuspended = false\n  }, [getLatestConfig, query, refetch])\n\n  // Handle refetch interval\n  React.useEffect(() => {\n    const query = queryRef.current\n    if (\n      config.refetchInterval &&\n      (!query.currentRefetchInterval ||\n        // shorter interval should override previous one\n        config.refetchInterval < query.currentRefetchInterval)\n    ) {\n      query.currentRefetchInterval = config.refetchInterval\n      clearInterval(query.refetchIntervalId)\n      query.refetchIntervalId = setInterval(() => {\n        if (isDocumentVisible() || config.refetchIntervalInBackground) {\n          refetch().catch(Console.error)\n        }\n      }, config.refetchInterval)\n\n      return () => {\n        clearInterval(query.refetchIntervalId)\n        delete query.refetchIntervalId\n        delete query.currentRefetchInterval\n      }\n    }\n  }, [config.refetchInterval, config.refetchIntervalInBackground, refetch])\n\n  return {\n    ...query.state,\n    config,\n    query,\n    refetch,\n  }\n}\n","import { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function useQuery(...args) {\n  const query = useBaseQuery(...getQueryArgs(args))\n\n  handleSuspense(query)\n\n  return query\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, handleSuspense } from './utils'\n\nexport function usePaginatedQuery(...args) {\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const lastDataRef = React.useRef()\n\n  if (!queryKey) {\n    lastDataRef.current = undefined\n  }\n\n  // If latestData is set, don't use initialData\n  if (typeof lastDataRef.current !== 'undefined') {\n    delete config.initialData\n  }\n\n  const query = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  let { data: latestData, status } = query\n\n  React.useEffect(() => {\n    if (status === 'success' && typeof latestData !== 'undefined') {\n      lastDataRef.current = latestData\n    }\n  }, [latestData, status])\n\n  let resolvedData = latestData\n\n  if (typeof resolvedData === 'undefined') {\n    resolvedData = lastDataRef.current\n  }\n\n  if (typeof resolvedData !== 'undefined') {\n    status = 'success'\n  }\n\n  const paginatedQuery = {\n    ...query,\n    resolvedData,\n    latestData,\n    status,\n  }\n\n  handleSuspense(paginatedQuery)\n\n  return paginatedQuery\n}\n","import React from 'react'\n\n//\n\nimport { useBaseQuery } from './useBaseQuery'\nimport { getQueryArgs, useGetLatest, handleSuspense } from './utils'\n\nexport function useInfiniteQuery(...args) {\n  const queryInfoRef = React.useRef()\n  let [queryKey, queryVariables, queryFn, config = {}] = getQueryArgs(args)\n\n  const { getFetchMore } = config\n  const getGetFetchMore = useGetLatest(getFetchMore)\n\n  // The default queryFn will query all pages and map them together\n  const originalQueryFn = queryFn\n\n  queryFn = async () => {\n    const data = []\n    const pageVariables = [...queryInfoRef.current.query.pageVariables]\n    const rebuiltPageVariables = []\n\n    do {\n      const args = pageVariables.shift()\n\n      if (!data.length) {\n        // the first page query doesn't need to be rebuilt\n        data.push(await originalQueryFn(...args))\n        rebuiltPageVariables.push(args)\n      } else {\n        // get an up-to-date cursor based on the previous data set\n        const nextCursor = getGetFetchMore()(data[data.length - 1], data)\n\n        // break early if there's no next cursor\n        // otherwise we'll start from the beginning\n        // which will cause unwanted duplication\n        if (!nextCursor) {\n          break\n        }\n\n        const pageArgs = [\n          // remove the last argument (the previously saved cursor)\n          ...args.slice(0, -1),\n          nextCursor,\n        ]\n\n        data.push(await originalQueryFn(...pageArgs))\n        rebuiltPageVariables.push(pageArgs)\n      }\n    } while (pageVariables.length)\n\n    queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n      data[data.length - 1],\n      data\n    )\n    queryInfoRef.current.query.pageVariables = rebuiltPageVariables\n\n    return data\n  }\n\n  const queryInfo = useBaseQuery(queryKey, queryVariables, queryFn, config)\n\n  if (\n    typeof queryInfo.query.canFetchMore === 'undefined' &&\n    typeof queryInfo.data !== 'undefined'\n  ) {\n    queryInfo.query.canFetchMore = getGetFetchMore()(\n      queryInfo.data[queryInfo.data.length - 1],\n      queryInfo.data\n    )\n  }\n\n  queryInfoRef.current = queryInfo\n\n  let {\n    refetch,\n    data = [],\n    query: { canFetchMore },\n  } = queryInfo\n\n  // Here we seed the pageVariabes for the query\n  if (!queryInfo.query.pageVariables) {\n    queryInfo.query.pageVariables = [\n      [...queryInfo.query.queryKey, ...queryInfo.query.queryVariables],\n    ]\n  }\n\n  const fetchMore = React.useCallback(\n    (fetchMoreInfo = queryInfoRef.current.query.canFetchMore) =>\n      queryInfoRef.current.query.canFetchMore\n        ? refetch({\n            force: true,\n            __queryFn: async (...args) => {\n              try {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: true,\n                }))\n\n                const newArgs = [...args, fetchMoreInfo]\n                queryInfoRef.current.query.pageVariables.push(newArgs)\n\n                const data = [\n                  ...queryInfoRef.current.data,\n                  await originalQueryFn(...newArgs),\n                ]\n\n                queryInfoRef.current.query.canFetchMore = getGetFetchMore()(\n                  data[data.length - 1],\n                  data\n                )\n\n                return data\n              } finally {\n                queryInfoRef.current.query.setState(old => ({\n                  ...old,\n                  isFetchingMore: false,\n                }))\n              }\n            },\n          })\n        : void 0,\n    [getGetFetchMore, originalQueryFn, refetch]\n  )\n\n  handleSuspense(queryInfo)\n\n  return {\n    ...queryInfo,\n    data,\n    canFetchMore,\n    fetchMore,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}